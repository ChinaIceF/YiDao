# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'YIDdaoUI.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

from PyQt5.QtCore import *
from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import *
from PyQt5.Qt import *
import sys
import time
import random
import copy
import numpy as np
from PIL import Image,ImageFont, ImageDraw

empty=[]
Neural=[]
for indexX in range(75):
  empty.extend([[]])
for indexY in range(6):
  Neural.extend([empty[:]])

def moveHighLight(self,endY,level,delay=1/240,f=31):
   
    startY_highlight = self.SideBar_Highlight.geometry().y()
    startY_slider = self.UISlider.geometry().y()
    for index in range(f):
      rawY=1/(1+2**(-20*(index/(f-1)-0.5)))
      newH=int(48*(0.75*(index/(f-1))*(index/(f-1)-1)+1))
      newY_highlight = int((endY - startY_highlight) * rawY) + startY_highlight + 0.5 * (48 - newH)
      newY_slider = - int((level * 708 - abs(startY_slider)) * rawY + abs(startY_slider))

      self.SideBar_Highlight.setGeometry(QtCore.QRect(100, newY_highlight, 284, newH))
      self.UISlider.setGeometry(QtCore.QRect(0, newY_slider, 916, 3572))
      time.sleep(delay)
      QApplication.processEvents()





#def returnChess(self.posx,posy):
#    return chessAll[posx][posy]

class Ui_Dialog(object):
    
    def drawDiagramMap(self,mapA,mapB):
      
      ##  第一张
      tmpTransform = np.array(mapA,dtype="float64")
      tmpMax = tmpTransform.max()
      tmpMin = tmpTransform.min()
      tmpBool = abs(tmpMax) - abs(tmpMin) > 0
      
      if tmpMax*tmpMin >= 0:
        limitVal = tmpMax
      else:
        limitVal = int(tmpBool) * tmpMax + -int(not tmpBool) * tmpMin

      frame = Image.open("texture//diagram.png")
      basemark = Image.open("texture/basemark.png").convert('RGBA')
      for indexX in range(9):
        for indexY in range(10):

          tmpVal = mapA[indexX][indexY]
          
          #frame.paste(basemark,(300+indexX*12,75+indexY*12),basemark)
          if tmpVal != 0 :
            
            if tmpVal > 0:
              mark  = Image.open("texture/mark_0.png").convert('RGBA')
              tmpTrans = (tmpVal / limitVal) * 0.75 + 0.25
            else:
              mark  = Image.open("texture/mark_1.png").convert('RGBA')
              tmpTrans = -(tmpVal / limitVal) * 0.75 + 0.25
          
            mark = mark.convert('RGBA')
            img_blender = Image.new('RGBA', mark.size, (202,206,215,0))  # 往白变淡就用255,255,255
            mark = Image.blend(img_blender, mark, tmpTrans)
            frame.paste(mark,(312+indexX*12,90+indexY*12),mark)


      ##  第2张
      tmpTransform = np.array(mapB[0],dtype="float64")
      tmpMax = tmpTransform.max()
      tmpMin = tmpTransform.min()
      tmpBool = abs(tmpMax) - abs(tmpMin) > 0
      
      if tmpMax*tmpMin >= 0:
        limitVal = abs(int(tmpBool) * tmpMax + int(not tmpBool) * tmpMin)
      else:
        limitVal = abs(int(tmpBool) * tmpMax + -int(not tmpBool) * tmpMin)

      basemark = Image.open("texture/basemark.png").convert('RGBA')
      for index in range(len(mapB[1])):
          objectPos = mapB[1][index]
          tmpVal = mapB[0][index]
          
          indexX = objectPos[2]
          indexY = objectPos[3]
          
          #frame.paste(basemark,(300+indexX*12,75+indexY*12),basemark)
          if tmpVal != 0 :
            
            if tmpVal > 0:
              mark  = Image.open("texture/mark_0.png").convert('RGBA')
              tmpTrans = (tmpVal / limitVal) * 0.5 + 0.5
            else:
              mark  = Image.open("texture/mark_1.png").convert('RGBA')
              tmpTrans = -(tmpVal / limitVal) * 0.5 + 0.5
          
            print(tmpTrans, tmpVal)
            mark = mark.convert('RGBA')
            img_blender = Image.new('RGBA', mark.size, (202,206,215,0))  # 往白变淡就用255,255,255
            mark = Image.blend(img_blender, mark, tmpTrans)
            frame.paste(mark,(549+indexX*12,90+indexY*12),mark)

          
      frame.save("temp//diagram_gen.png")
      self.Diagram.setPixmap(QtGui.QPixmap("temp/diagram_gen.png"))
    
    def checkChooseChess(self):
        if self.chooseChessDone == True:
          self.chooseChessDone = False
          tmpChessPos = self.chooseChessPos
          self.chooseChessPos = []
          return True,tmpChessPos
        else:
          return False,self.chooseChessPos
    
    def setChess(self,posx,posy,ShowType=True,ChessType=0):
        #print(self.chessAll)
        self.chessAll[posx][posy].setVisible(ShowType)
        self.chessAll[posx][posy].chesstype = ChessType
        self.chessAll[posx][posy].setPixmap(QtGui.QPixmap("texture/"+str(ChessType)))
        
    
    #def setValueBar(self,level,value):
        
      
    
    def setupUi(self, Dialog):
        
        print(self)
        self.setWindowFlags(Qt.FramelessWindowHint)  # 去边框
        self.setAttribute(Qt.WA_TranslucentBackground)  # 设置窗口背景透明

        Dialog.setObjectName("Dialog")
        Dialog.resize(1401, 941)
        Dialog.setAcceptDrops(False)
        
        ##  主窗口
        self.MainWindow = QtWidgets.QLabel(Dialog)
        self.MainWindow.setGeometry(QtCore.QRect(0, 0, 1401, 941))
        self.MainWindow.setFocusPolicy(QtCore.Qt.NoFocus)
        self.MainWindow.setAcceptDrops(True)
        self.MainWindow.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.MainWindow.setAutoFillBackground(False)
        self.MainWindow.setInputMethodHints(QtCore.Qt.ImhHiddenText)
        self.MainWindow.setText("")
        self.MainWindow.setPixmap(QtGui.QPixmap("texture/background.png"))
        self.MainWindow.setScaledContents(False)
        self.MainWindow.setObjectName("MainWindow")
        
        ##  左  高光条
        self.SideBar_Highlight = QtWidgets.QLabel(Dialog)
        self.SideBar_Highlight.setGeometry(QtCore.QRect(100, 330, 291, 48))
        self.SideBar_Highlight.setText("")
        self.SideBar_Highlight.setPixmap(QtGui.QPixmap("texture/highlight.png"))
        self.SideBar_Highlight.setObjectName("SideBar_Highlight")
        
        ##  左  数值
        self.SideBar_Net = QtWidgets.QLabel(Dialog)
        self.SideBar_Net.setGeometry(QtCore.QRect(100, 330, 284, 48))
        self.SideBar_Net.setText("")
        self.SideBar_Net.setPixmap(QtGui.QPixmap("texture/toolbar1.png"))
        self.SideBar_Net.setObjectName("SideBar_Net")
        
        ##  左  棋盘
        self.SideBar_Board = QtWidgets.QLabel(Dialog)
        self.SideBar_Board.setGeometry(QtCore.QRect(100, 380, 284, 48))
        self.SideBar_Board.setText("")
        self.SideBar_Board.setPixmap(QtGui.QPixmap("texture/toolbar2.png"))
        self.SideBar_Board.setObjectName("SideBar_Board")
        
        ##  左  设置
        self.SideBar_Set = QtWidgets.QLabel(Dialog)
        self.SideBar_Set.setGeometry(QtCore.QRect(100, 430, 284, 48))
        self.SideBar_Set.setText("")
        self.SideBar_Set.setPixmap(QtGui.QPixmap("texture/toolbar3.png"))
        self.SideBar_Set.setObjectName("SideBar_Set")
        
        ##  左  捐助
        self.SideBar_Donate = QtWidgets.QLabel(Dialog)
        self.SideBar_Donate.setGeometry(QtCore.QRect(100, 500, 284, 48))
        self.SideBar_Donate.setText("")
        self.SideBar_Donate.setPixmap(QtGui.QPixmap("texture/toolbar4.png"))
        self.SideBar_Donate.setObjectName("SideBar_Donate")
        
        ##  左  退出键
        self.SideBar_Exit = QtWidgets.QLabel(Dialog)
        self.SideBar_Exit.setGeometry(QtCore.QRect(100, 650, 284, 48))
        self.SideBar_Exit.setText("")
        self.SideBar_Exit.setPixmap(QtGui.QPixmap("texture/toolbar5.png"))
        self.SideBar_Exit.setObjectName("SideBar_Exit")
        
        ##  左  版权声明
        self.SideBar_Copyright = QtWidgets.QLabel(Dialog)
        self.SideBar_Copyright.setGeometry(QtCore.QRect(100, 700, 284, 140))
        self.SideBar_Copyright.setText("")
        self.SideBar_Copyright.setPixmap(QtGui.QPixmap("texture/copyright.png"))
        self.SideBar_Copyright.setObjectName("SideBar_Copyright")
        
        ##  右  主界面透窗
        self.RightWindow = QtWidgets.QLabel(Dialog)
        self.RightWindow.setGeometry(QtCore.QRect(384, 116, 916, 708))
        self.RightWindow.setText("")
        #self.RightWindow.setPixmap(QtGui.QPixmap("texture/RightWindow.png"))
        self.RightWindow.setObjectName("RightWindow")
        
        ##  透窗  滑动UI条
        self.UISlider = QtWidgets.QLabel(self.RightWindow)  #父对象是透窗
        self.UISlider.setGeometry(QtCore.QRect(0, 0, 916, 3572))
        self.UISlider.setText("")
        #self.UISlider.setPixmap(QtGui.QPixmap("texture/UISlider.png"))
        self.UISlider.setObjectName("UISlider")
        
        
        ##  数据
        self.Net = QtWidgets.QLabel(self.UISlider)
        self.Net.setGeometry(QtCore.QRect(0, 0, 916, 740))
        self.Net.setText("")
        self.Net.setObjectName("Net")
        self.Net.setVisible(True)
        
        self.Net_Diagram = QtWidgets.QLabel(self.Net)
        self.Net_Diagram.setGeometry(QtCore.QRect(10, 60, 284, 48))
        self.Net_Diagram.setText("")
        self.Net_Diagram.setPixmap(QtGui.QPixmap("texture/neural1.png"))
        self.Net_Diagram.setObjectName("Net_Diagram")
        
        self.Net_Value = [[0.75],[0.77],[0.6],[0.2],[0.5],[0.24]]
        for index in range(6):
          tmpX = 282
          tmpY = 188
          tmpStep = 60
          tmpTransLimit = 0.4
          tmpTrans = self.Net_Value[index][0] * (1 - tmpTransLimit) + tmpTransLimit
        
          #  前半
          self.Net_Value[index] += [QtWidgets.QLabel(self.Net)]
          self.Net_Value[index][1] = QtWidgets.QLabel(self.Net)
          self.Net_Value[index][1].setGeometry(QtCore.QRect(tmpX, tmpY+index*30, 3, 6))
          self.Net_Value[index][1].setText("")
          self.Net_Value[index][1].setPixmap(QtGui.QPixmap("texture/valuebar_start.png"))
          self.Net_Value[index][1].setObjectName("Value_head_"+str(index))
          
          #  中间
          self.Net_Value[index] += [QtWidgets.QLabel(self.Net)]
          self.Net_Value[index][2] = QtWidgets.QLabel(self.Net)
          self.Net_Value[index][2].setGeometry(QtCore.QRect(tmpX+3, tmpY+index*30, int(494*self.Net_Value[index][0]), 6))
          self.Net_Value[index][2].setText("")
          self.Net_Value[index][2].setPixmap(QtGui.QPixmap("texture/valuebar_body.png"))
          self.Net_Value[index][2].setObjectName("Value_body_"+str(index))
          
          #  结尾
          self.Net_Value[index] += [QtWidgets.QLabel(self.Net)]
          self.Net_Value[index][3] = QtWidgets.QLabel(self.Net)
          self.Net_Value[index][3].setGeometry(QtCore.QRect(tmpX+3+494*self.Net_Value[index][0], tmpY+index*30, 3, 6))
          self.Net_Value[index][3].setText("")
          self.Net_Value[index][3].setPixmap(QtGui.QPixmap("texture/valuebar_end.png"))
          self.Net_Value[index][3].setObjectName("Value_end_"+str(index))
          
          for index_ in range(3):
          
            op = QtWidgets.QGraphicsOpacityEffect()
            op.setOpacity(tmpTrans)

            self.Net_Value[index][index_+1].setGraphicsEffect(op)


        self.temp1 = QtWidgets.QLabel(self.Net)
        self.temp1.setGeometry(QtCore.QRect(80, 110, 734, 300))
        self.temp1.setText("")
        self.temp1.setPixmap(QtGui.QPixmap("texture/temp1.png"))
        self.temp1.setObjectName("temp1")
        
        self.Diagram = QtWidgets.QLabel(self.Net)
        self.Diagram.setGeometry(QtCore.QRect(0, 360, 916, 300))
        self.Diagram.setText("")
        self.Diagram.setPixmap(QtGui.QPixmap("texture/diagram.png"))
        self.Diagram.setObjectName("Diagram")

        

        ##   棋盘
        self.Board = QtWidgets.QLabel(self.UISlider)
        self.Board.setText("")
        self.Board.setObjectName("Board")
        self.Board.setGeometry(QtCore.QRect(0, 708, 916, 740))
        self.Board.setVisible(True)

        self.Board_Board = QtWidgets.QLabel(self.Board)
        self.Board_Board.setGeometry(QtCore.QRect(72, 32, 583, 652))
        self.Board_Board.setText("")
        self.Board_Board.setPixmap(QtGui.QPixmap("texture/chessboard.png"))
        self.Board_Board.setObjectName("Board_Board")
        
        48*48
        self.chessAll = []
        for posX in range(0,9,1):
        
          chessline = []
          for posY in range(0,10,1):
            
            newObject = QtWidgets.QLabel(self.Board)
            newObject.setGeometry(QtCore.QRect(posX*56+110, posY*56+77, 56, 56))
            newObject.setText("")
            newObject.setPixmap(QtGui.QPixmap("texture/chesstest.png"))
            newObject.setObjectName("chess_"+str(posX)+"_"+str(posY))
            newObject.chesstype = 0
            chessline.extend([newObject])
          
          self.chessAll.extend([chessline])
        
        
        
        ##   设置
        self.Set = QtWidgets.QLabel(self.UISlider)
        self.Set.setText("")
        self.Set.setObjectName("Set")
        self.Set.setGeometry(QtCore.QRect(0, 708*2, 916, 740))
        self.Set.setPixmap(QtGui.QPixmap("texture/set_dev.png"))
        self.Set.setVisible(True)
        
        ##   捐助
        self.Donate = QtWidgets.QLabel(self.UISlider)
        self.Donate.setText("")
        self.Donate.setObjectName("Donate")
        self.Donate.setGeometry(QtCore.QRect(0, 708*3, 916, 740))
        self.Donate.setPixmap(QtGui.QPixmap("texture/donate.png"))
        self.Donate.setVisible(True)
        
        ##   告别界面
        self.Bye = QtWidgets.QLabel(self.UISlider)
        self.Bye.setText("")
        self.Bye.setObjectName("Bye")
        self.Bye.setGeometry(QtCore.QRect(0, 708*4, 916, 740))
        self.Bye.setPixmap(QtGui.QPixmap("texture/Bye.png"))
        self.Bye.setVisible(True)
        
        
        ##  透窗  柔色叠加图层，要放在最后，不然会被覆盖
        self._AddBuffer = QtWidgets.QLabel(self.RightWindow)
        self._AddBuffer.setGeometry(QtCore.QRect(0, 0, 916, 708))
        self._AddBuffer.setText("")
        self._AddBuffer.setPixmap(QtGui.QPixmap("texture/_AddBuffer.png"))
        self._AddBuffer.setObjectName("RightWindow")
        
        
        
        
        
        
        self.nowSelect = self.Net
        self.chooseChessCount = 0
        self.chooseChessPos = []
        self.chooseChessDone = False
        
        '''
        #定义神经网络组
        global  Neural
        
        for indexY in range(6):
          for indexX in range(5):
            Neural[indexY][indexX] = QtWidgets.QLabel(self.Net)
            thisNeural = Neural[indexY][indexX]
            thisNeural.setGeometry(QtCore.QRect(82+indexX*150, 140+indexY*40, 8, 22))
            thisNeural.setText("")
            thisNeural.setPixmap(QtGui.QPixmap("texture/mark.png"))
            thisNeural.setObjectName("Neural_"+str(indexY)+'_'+str(indexX))

            op = QtWidgets.QGraphicsOpacityEffect()
            op.setOpacity(random.randint(0,100)/100)
            thisNeural.setGraphicsEffect(op)

        QtCore.QMetaObject.connectSlotsByName(Dialog)
        self.animation = None
        '''



    def mousePressEvent(self, event):
        
        global Neural
        #print(Neural)
        
        #初始化各个控件的内存位置
        locate_MainWindow = self.findChild(QLabel, "MainWindow")
        locate_Net = self.findChild(QLabel, "SideBar_Net")
        locate_Board = self.findChild(QLabel, "SideBar_Board")
        locate_Set = self.findChild(QLabel, "SideBar_Set")
        locate_Donate = self.findChild(QLabel, "SideBar_Donate")
        locate_Exit = self.findChild(QLabel, "SideBar_Exit")
        locate_RightWindow = self.findChild(QLabel, "RightWindow")
        self.m_flag = False
        
        
        if event.button() == Qt.LeftButton:
            
            self.m_Position = event.globalPos() - self.pos()  # 获取鼠标相对窗口的位置
            mouseAt = self.childAt(self.m_Position.x(), self.m_Position.y()) #获取鼠标点击的控件
            #print(self.UISlider.geometry().x(),self.UISlider.geometry().y(),mouseAt.objectName())
            
            if mouseAt.objectName() == "RightWindow" :  #在右侧窗口
              
              base_Position = self.nowSelect.geometry()
              modify_Position = QPoint(base_Position.x()+384,100+16)
              self.m_Position = event.globalPos() - self.pos() -  modify_Position
              mouseAt = self.nowSelect.childAt(self.m_Position)
              if mouseAt is not None:
                name_mouseAt = mouseAt.objectName()
                print(name_mouseAt,self.nowSelect.objectName() ,self.m_Position)
                
                if name_mouseAt.find("chess_") > -1 :
                  
                  self.chooseChessDone = False
                  self.chooseChessCount += 1
                  tmpPos = name_mouseAt.replace("chess_","").split("_")
                  print("选择了一个棋子，这是第",self.chooseChessCount,"次")
                  self.chooseChessPos.extend([tmpPos[0],tmpPos[1]])
                  
                  if self.chooseChessCount == 2 :
                    #  判断是不是取消
                    if ( self.chooseChessPos[0]==self.chooseChessPos[2] and 
                           self.chooseChessPos[1]==self.chooseChessPos[3] ):

                      self.chooseChessCount = 0
                      self.chooseChessPos = []
                      print("已取消移动棋子")

                    else:

                      self.chooseChessDone = True
                      self.chooseChessCount = 0
                
              else:
                print("在这里没有找到控件",self.m_Position)
                
                
            
            else:
              #print(mouseAt)
              if mouseAt == locate_MainWindow:
                print('locate_MainWindow')
              
              #先检测是不是拖动窗口事件
              if 100<self.m_Position.x()<384 and 100<self.m_Position.y()<132:
                self.m_flag = True
                event.accept()
                self.setCursor(QCursor(Qt.SizeAllCursor))  # 更改鼠标图标
              else:
                self.m_flag = False
                
                #好家伙，不是拖动窗口，检测是不是工具栏事件
                
                if mouseAt == locate_Net:
                  self.nowSelect = self.Net
                  print('locate_Net')
                  moveHighLight(self,330,0)

                elif mouseAt == locate_Board:
                  self.nowSelect = self.Board
                  print('locate_Board')
                  moveHighLight(self,380,1)
                  
                elif mouseAt == locate_Set:
                  self.nowSelect = self.Set
                  print('locate_Set')
                  moveHighLight(self,430,2)
                  
                elif mouseAt == locate_Donate:
                  self.nowSelect = self.Donate
                  print('locate_Donate')
                  moveHighLight(self,500,3)
                  
                elif mouseAt == locate_Exit:
                  print('locate_Exit')
                  moveHighLight(self,650,4)
                  time.sleep(0.3)
                  self.close()

    def mouseMoveEvent(self, QMouseEvent):
        if Qt.LeftButton and self.m_flag:
            self.move(QMouseEvent.globalPos() - self.m_Position)  # 更改窗口位置
            QMouseEvent.accept()
 
    def mouseReleaseEvent(self, QMouseEvent):
        self.m_flag = False
        self.setCursor(QCursor(Qt.ArrowCursor))

    def closeEvent(self, event):
        if self.animation is None:
            self.animation = QPropertyAnimation(self, b'windowOpacity')
            self.animation.setDuration(300)
            self.animation.setStartValue(1)
            self.animation.setEndValue(0)
            self.animation.finished.connect(self.close)
            self.animation.start()
            event.ignore()

    
        
if __name__=='__main__':
    Ui_Dialog().show()
